typeof：只是一个操作符，不是一个函数的， 所以使用的时候不一定必须加上括号的。

undefined、null、Boolean、number、String

<img src=""  alt = "" />

## HTML 图像- 图像标签（ <img>）和源属性（Src）

在 HTML 中，图像由<img> 标签定义。

<img> 是空标签，意思是说，它只包含属性，并且没有闭合标签。

要在页面上显示图像，你需要使用源属性（src）。src 指 "source"。源属性的值是图像的 URL 地址。

**定义图像的语法是：**

<img src="url" alt="some_text">

URL 指存储图像的位置。如果名为 "pulpit.jpg" 的图像位于 www.runoob.com 的 images 目录中，那么其 URL 为 [http://www.runoob.com/images/pulpit.jpg](https://www.runoob.com/images/pulpit.jpg)。

浏览器将图像显示在文档中图像标签出现的地方。如果你将图像标签置于两个段落之间，那么浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。

------

## HTML 图像- Alt属性

alt 属性用来为图像定义一串预备的可替换的文本。

替换文本属性的值是用户定义的。

<img src="boat.gif" alt="Big Boat">

在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。

------

## HTML 图像- 设置图像的高度与宽度

height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。

属性值默认单位为像素:

<img src="pulpit.jpg" alt="Pulpit rock" width="304" height="228">

**提示:** 指定图像的高度和宽度是一个很好的习惯。如果图像指定了高度宽度，页面加载时就会保留指定的尺寸。如果没有指定图片的大小，加载页面时有可能会破坏HTML页面的整体布局。

------

## 基本的注意事项 - 有用的提示：

**注意:** 假如某个 HTML 文件包含十个图像，那么为了正确显示这个页面，需要加载 11 个文件。加载图片是需要时间的，所以我们的建议是：慎用图片。

**注意:** 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。

前端中图片的格式都有：JPEG、PNG、GIF、SVG、

然后图片过多的时候处理的方法有:[【前端攻略】：玩转图片Base64编码](https://www.cnblogs.com/coco1s/p/4375774.html)

图片下载始终都是要向服务器发出请求的,原本的图片是需要单独的进行一次http请求来下载下来的,然后现在直接使用对应的下载HTML的同时直接下载图片下来,这就是base64技术的核心.

**如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新**。

除了Base64编码后使用雪碧图完成实现:

生成雪碧图的软件: https://www.99css.com/cssgaga/

前端构建工具gulp:https://www.cnblogs.com/2050/p/4198792.html

前端CSS拓展语言:SASS学习:

前端面试题目篇css:https://www.cnblogs.com/zhangshuda/p/8465043.html



1.[使用link和@import有什么区别](mailto:使用link和@import有什么区别)？

​	我们都知道在html中引入外部的CSS 有2种方式，link标签和@import，他们又什么区别呢？

**1.从属关系区别**
@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**
加载页面时，**link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载**。

**3.兼容性区别**
@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。

**4.DOM可控性区别**
可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。

**5.权重区别(该项有争议，下文将详解)**
link引入的样式权重大于@import引入的样式。

<style type="text/css">
    @import 'style.css' //Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别
    @import "style.css" //Windows IE4/ NS4, Macintosh IE4/NS4不识别
    @import url(style.css) //Windows NS4, Macintosh NS4不识别
    @import url('style.css') //Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别
    @import url("style.css") //Windows NS4, Macintosh NS4不识别
</style>

```css
<link href="style.css" rel="stylesheet" type="text/css"> 
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
```

2.[HTML中的IE条件注释](https://www.cnblogs.com/borage/p/4747464.html)

<!-- this is a comment -->

IE条件注释是一种特殊的HTML注释，这种注释只有IE5.0及以上版本才能理解。比如普通的HTML注释是：

```
<!--This is a comment-->
```

　　而只有IE可读的IE条件注释是：

```
<!--[if IE]> <![endif]-->
```

　　“非IE条件注释”：

```
<!--[if !IE]>--> non-IE HTML Code <!--<![endif]-->
```

　　“非特定版本IE条件注释”（很少用到）：

```
<!--[if ! lt IE 7]><![IGNORE[--><![IGNORE[]]>Code for browsers that match the if condition<!--<![endif]-->
```

　　简而言之，除了“Windows上的IE”之外的所有浏览器都会认为条件注释只是一段普通的HTML注释。你不能在CSS代码中使用条件注释。IE条件注释是很有用的对IE隐藏或者展现特定代码的方法，比起在CSS中用诡异的_/制造bug，利用IE条件注释来写CSS “hacks”是更合理的方法。通俗点，条件注释就是一些if判断，但这些判断不是在脚本里执行的，而是直接在html代码里执行的。

1. 条件注释的基本结构和HTML的注释(<!– –>)是一样的。因此IE以外的浏览器将会把它们看作是普通的注释而完全忽略它们。
2. IE将会根据if条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。
3. 条件注释使用的是HTML的注释结构，因此他们只能使用在HTML文件里，而不能在CSS文件中使用。

　　从语法上看这是相当合法的普通HTML注释。任何浏览器都会认为<!–和–>之间的部分是注释从而忽略它。但是IE也会看到其中[if IE]>，从而开始解释接下来的代码直到遇到<![endif]。所以，下面这些代码不会显示在任何其他浏览器中面。

　　通过“比较操作符”可以更灵活地对IE版本进行控制，用法是在IE前面加上“比较操作符”。合法的操作符如下：

- **lte：就是Less than or equal to的简写，也就是小于或等于的意思。**

- **lt ：就是Less than的简写，也就是小于的意思。**

- **gte：就是Greater than or equal to的简写，也就是大于或等于的意思。**

- **gt ：就是Greater than的简写，也就是大于的意思。**

- **! ：就是不等于的意思，跟javascript里的不等于判断符相同**

  　　示例：**l 就是less.t就是than.e就是equal等于.然后!就是代表取反不等于的意思**

  - <!–[if gt IE 5.5]> / 如果IE版本大于5.5 /
  - <!–[if lte IE 6]> / 如果IE版本小于等于6 /
  - <!–[if !IE]> / 如果浏览器不是IE /

  　　虽然看上去当你第一次使用条件注释的时候会更费时，但当你以后调试你的CSS的时候，就会发现非常方便。用条件注释你只需要写一遍HTML注释，而用bug你需要为每一条规则都写上又长又丑的代码，而且还经常是为了改变其他的hacks而写的hacks。除此之外条件注释对于不支持它的任何浏览器而言都是合法的HTML注释。以下为条件注释与CSS hacks的一些区别：

  1. Hacks是基于浏览器的bug，而这些bug最终可能会被修复。
  2. 条件注释是基于IE特定代码，这种识别机制任何时候都不会被移除。
  3. 每一个浏览器都能看见你的hacks，或许下一个版本或者一个新的浏览器会在你的hacks代码上出错。
  4. 只有IE才能看到条件注释，通过额外的“IE文件”来影响页面，其他浏览器根本就不会下载它。
  5. Hacks不能确保对哪些浏览器生效而对哪些不，用的hacks越多，代码越混乱。
  6. 条件注释利用版本匹配使得作者可以容易地对特定版本写代码。

SASS语言:

​	Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 [Compass](http://compass-style.org/)）有助于更好地组织管理样式文件，以及更高效地开发项目。

​	**1. 特色功能 (Features)**

- 完全兼容 CSS3
- 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能
- 通过[函数](http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html)进行颜色值与属性值的运算
- 提供[控制指令 (control directives)](https://www.sass.hk/docs/#t8)等高级功能
- 自定义输出格式

## 2. 语法格式 (Syntax)

Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 `.scss` 作为拓展名。

另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 "Sass"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 [the indented syntax reference](http://sass-lang.com/docs/yardoc/file.INDENTED_SYNTAX.html)。这种格式以 `.sass` 作为拓展名。

任何一种格式可以直接 [导入 (@import)](https://www.sass.hk/docs/#t7-1) 到另一种格式中使用，或者通过 `sass-convert` 命令行工具转换成另一种格式：

```SASS
# Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
```

## 3. 使用 Sass (Using Sass)

Sass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先[安装 Ruby](http://rubyinstaller.org/)）：

```
gem install sass
```

在命令行中运行 Sass：

```
sass input.scss output.css
```

监视单个 Sass 文件，每次修改并保存时自动编译：

```
sass --watch input.scss:output.css
```

监视整个文件夹：

```
sass --watch app/sass:public/stylesheets
```

更多命令的用法请通过 `sass --help` 获取帮助。

在 Ruby 中使用 Sass 也非常容易，Sass gem 安装完毕后运行 `require "sass"` 然后按照下面的方法使用 [Sass::Engine](http://sass-lang.com/docs/yardoc/Sass/Engine.html)：

```
engine = Sass::Engine.new("#main {background-color: #0000ff}", :syntax => :scss)
engine.render #=> "#main { background-color: #0000ff; }\n"
```

### 3.2. 缓存 (Caching)

Sass 自动缓存编译后的模板与 [partials](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#partials)，这样做能够显著提升重新编译的速度，尤其在处理由 `@import` 导入多个子文件的大型项目时。

单独使用 Sass，缓存内容保存在 `.sass-cache` 文件夹中。在 Rails 和 Merb 项目中缓存文件保存在 `tmp/sass-cache` 文件夹中（可通过 [`:cache_location`](https://www.sass.hk/docs/) 修改路径）。禁用缓存可将 `:cache` 设为 `false`。

## 4. CSS 功能拓展 (CSS Extensions)

### 4.1. 嵌套规则 (Nested Rules)

Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：

```scss
#main p {
  color: #00ff00;
  width: 97%;

  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
//这个的编译结果就是等同于其中的CSS中的包含选择器!
```

编译为

```css
#main p {
  color: #00ff00;
  width: 97%; }
  #main p .redbox {
    background-color: #ff0000;
    color: #000000; }
```

嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：

```scss
#main {
  width: 97%;

  p, div {
    font-size: 2em;
    a { font-weight: bold; }
  }

  pre { font-size: 3em; }
}
```

编译为

```css
#main {
  width: 97%; }
  #main p, #main div {
    font-size: 2em; }
    #main p a, #main div a {
      font-weight: bold; }
  #main pre {
    font-size: 3em; }
```

### 4.2. 父选择器 `&` (Referencing Parent Selectors: `&`)

在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 `hover` 样式时，或者当 `body` 元素有某个 classname 时，可以用 `&` 代表嵌套规则外层的父选择器。

```scss
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}
//也就是直接将父选择器作为当前的选择器的前缀值.
```

编译为

```css
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }
```

编译后的 CSS 文件中 `&` 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}
```

编译为

```css
#main {
  color: black; }
  #main a {
    font-weight: bold; }
    #main a:hover {
      color: red; }
```

`&` 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如

```scss
#main {
  color: black;
  &-sidebar { border: 1px solid; }
}
```

编译为

```css
#main {
  color: black; }
  #main-sidebar {
    border: 1px solid; }
```

当父选择器含有不合适的后缀时，Sass 将会报错。

### 4.3. 属性嵌套 (Nested Properties)

有些 CSS 属性遵循相同的命名空间 (namespace)，比如 `font-family, font-size, font-weight` 都以 `font` 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

编译为

```css
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; }
```

命名空间也可以包含自己的属性值，例如：

```scss
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
```

编译为

```css
.funky {
  font: 20px/24px;
    font-family: fantasy;
    font-weight: bold; }
```

5.注释的语句和C++中的语法完全相同的.

### 6.2. 变量 `$` (Variables: `$`)

SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：

```scss
$width: 5em;
$height: 10px;
//而且变量具有块级作用域,需要将对应的局部变量设置为全局的变量的时候使用!global的方式.
```

直接使用即调用变量：

```css
#main {
  width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

编译为

```css
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```

### 6.3. 数据类型 (Data Types)

SassScript 支持 6 种主要的数据类型：

- 数字，`1, 2, 13, 10px`
- 字符串，有引号字符串与无引号字符串，`"foo", 'bar', baz`
- 颜色，`blue, #04a3f9, rgba(255,0,0,0.5)`
- 布尔型，`true, false`
- 空值，`null`
- 数组 (list)，用空格或逗号作分隔符，`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`
- maps, 相当于 JavaScript 的 object，`(key1: value1, key2: value2)`

SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 `!important` 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。

#### 6.3.1. 字符串 (Strings)

SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 `"Lucida Grande"` `'http://sass-lang.com'`；与无引号字符串 (unquoted strings)，如 `sans-serif` `bold`，在编译 CSS 文件时不会改变其类型。只有一种情况例外，**使用 `#{}` (interpolation) 时，有引号字符串将被编译为无引号字符串，**这样便于在 mixin 中引用选择器名：

```scss
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, Firefox users!";
  }
}
@include firefox-message(".header");
```

编译为

```css
body.firefox .header:before {
  content: "Hi, Firefox users!"; }
```

#### 6.3.2. 数组 (Lists)

数组 (lists) 指 Sass 如何处理 CSS 中 `margin: 10px 15px 0 0` 或者 `font-face: Helvetica, Arial, sans-serif` 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。

数组本身没有太多功能，但 [Sass list functions](http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html#list-functions) 赋予了数组更多新功能：`nth` 函数可以直接访问数组中的某一项；`join` 函数可以将多个数组连接在一起；`append` 函数可以在数组中添加新值；而 `@each` 指令能够遍历数组中的每一项。

数组中可以包含子数组，比如 `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。变化是，之前的 `1px 2px, 5px 6px` 使用逗号分割了两个子数组 (comma-separated)，而 `(1px 2px) (5px 6px)` 则使用空格分割(space-separated)。

当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 `(1px 2px) (5px 6px)` 与 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。

用 `()` 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 `font-family: ()` Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 `1px 2px () 3px` 或 `1px 2px null 3px`。

基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 `(1,)` 表示只包含 `1` 的数组，而 `(1 2 3,)` 表示包含 `1 2 3` 这个以空格分隔的数组的数组。

### 6.4. 运算 (Operations)

所有数据类型均支持相等运算 `==` 或 `!=`，此外，每种数据类型也有其各自支持的运算方式。

#### 6.4.1. 数字运算 (Number Operations)

SassScript 支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)，如果必要会在不同单位间转换值。

```scss
p {
  width: 1in + 8pt;
}
```

编译为

```css
p {
  width: 1.111in; }
```

关系运算 `<, >, <=, >=` 也可用于数字运算，相等运算 `==, !=` 可用于所有数据类型。

##### 6.4.1.1. 除法运算 `/` (Division and `/`)

`/` 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 `/` 除法运算的功能。也就是说，如果 `/` 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。

**以下三种情况 `/` 将被视为除法运算符号：**

- 如果值，或值的一部分，是变量或者函数的返回值
- 如果值被圆括号包裹
- 如果值是算数表达式的一部分

```scss
p {
  font: 10px/8px;             // Plain CSS, no division
  $width: 1000px;
  width: $width/2;            // Uses a variable, does division
  width: round(1.5)/2;        // Uses a function, does division
  height: (500px/2);          // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
}
```

编译为

```css
p {
  font: 10px/8px;
  width: 500px;
  height: 250px;
  margin-left: 9px; }
```

**如果需要使用变量，同时又要确保 `/` 不做除法运算而是完整地编译到 CSS 文件中，只需要用 `#{}` 插值语句将变量包裹**。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```

编译为:

```css
p {
  font: 12px/30px; }
```

**一些细节:**

1.有无引号的字符串相加的时候,什么在前面结果就是按照哪种格式出现的.如果有引号字符串（位于 `+` 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 `+` 左侧）连接有引号字符串，运算结果则没有引号。

在有引号的文本字符串中使用 `#{}` 插值语句可以添加动态的值：

```scss
p:before {
  content: "I ate #{5 + 10} pies!";
}
$value : null;
P:before{
    content:"T ara #{$value}";
}

//圆括号可以用来改变运算的优先级,圆括号内部的优先级较高的.
```

### 6.7. 插值语句 `#{}` (Interpolation: `#{}`)

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border; //本身变量可以定义为任何类型的数据的,字符串是不论是否有引号还是没有的.
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为

```css
p.foo {
  border-color: blue; }
```

`#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译 CSS。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```

编译为

```css
p {
  font: 12px/30px; }

//因为其本身就是将对应的变量直接放在对应的语句之中,那么使用其中的时候则可以完成对应的直接加入其中的实现,更多的需要在实际中去寻求对应的总结>?
```

&符号就是选择父元素的一种方式:简单的可以认为其就是父元素.

```scss
.foo.bar .baz.bang, .bip.qux {
  $selector: &; //代表着这里的& 就是父元素.
}
```

任何的语句之前都需要加上 @的方式:

```scss
@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  } @else {
    a {
      color: red;
    }
  }
}
//则可以使用这样的方式来完成检测是否存在对应的父元素的

```

### 6.9. 变量定义 `!default` (Variable Defaults: `!default`)

可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

```scss
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}

//就是说当前的可以根据其是否被赋值,然后来决定的,如果已经被赋值则后序的不会再次赋值的.
```

编译为

```css
#main {
  content: "First content";
  new-content: "First time reference"; }
```

变量是 null 空值时将视为未被 `!default` 赋值。

```scss
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
```

编译为

```css
#main {
  content: "Non-null content"; }
```

### 7.1. @import

Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。

Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 `:load_paths` 选项，或者在命令行中输入 `--load-path` 命令。

通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

- 文件拓展名是 `.css`；
- 文件名以 `http://` 开头；
- 文件名是 `url()`；
- `@import` 包含 media queries。

如果不在上述情况内，文件的拓展名是 `.scss` 或 `.sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。

```scss
@import "foo.scss";
```

或

```scss
@import "foo";
```

都会导入文件 foo.scss，但是

```scss
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

编译为

```css
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：

```scss
@import "rounded-corners", "text-shadow";
```

导入文件也可以使用 `#{ }` 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 `url()` 导入方式：

```scss
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}");
```

编译为

```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

#### 7.1.1. 分音 (Partials)

如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，**只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。**

例如，将文件命名为 `_colors.scss`，便不会编译 `_colours.css` 文件。

```scss
@import "colors";
```

上面的例子，导入的其实是 `_colors.scss` 文件.注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。

### 7.2. @media

Sass 中 `@media` 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 `@media` 嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 `@media` 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。

```scss
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
```

编译为

```css
.sidebar {
  width: 300px; }
  @media screen and (orientation: landscape) {
    .sidebar {
      width: 500px; } }
@media` 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 `and
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}
```

编译为

```css
@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px; } }
```

`@media` 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：

```scss
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;

@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}
```

编译为

```css
@media screen and (-webkit-min-device-pixel-ratio: 1.5) {
  .sidebar {
    width: 500px; } }
```

### 7.3. @extend

在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：

```markup
<div class="error seriousError">
  Oh no! You've been hacked!
</div>
```

样式如下

```css
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  border-width: 3px;
}
```

麻烦的是，这样做必须时刻记住使用 `.seriousError` 时需要参考 `.error` 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 `@extend` 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

上面代码的意思是将 `.error` 下的所有样式继承给 `.seriousError`，`border-width: 3px;` 是单独给 `.seriousError` 设定特殊样式，这样，使用 `.seriousError` 的地方可以不再使用 `.error`。

其他使用到 `.error` 的样式也会同样继承给 `.seriousError`，例如，另一个样式 `.error.intrusion` 使用了 `hacked.png` 做背景，`<div class="seriousError intrusion">` 也同样会使用 `hacked.png` 背景。

```css
.error.intrusion {
  background-image: url("/image/hacked.png");
}


// @extend的方式接受一个直接选择器然后得到对应的数据结果////
   @extend的方式得到的结果中对应的后面的结果的优先级是更高的.即后面的覆盖前面的选择
   多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。
       
```

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
.criticalError {
  @extend .seriousError;
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%;
}
既可以是多重的衍生的实现,重复的实现.
```

#### 7.3.6. @extend-Only 选择器 (@extend-Only Selectors)

有时，需要定义一套样式并不是给某个元素用，而是只通过 `@extend` 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。

如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 `id` 或 `class` 选择器，只是 `#` 或 `.` 被替换成了 `%`。可以像 class 或者 id 选择器那样使用，当它们单独使用时，**不会被编译到 CSS 文件中**。

```scss
// This ruleset won't be rendered on its own.
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
```

占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。

```scss
.notice {
  @extend %extreme;
}
```

编译为

```css
#context a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em; }
```

#### 7.3.8. 在指令中延伸 (@extend in Directives)

在指令中使用 `@extend` 时（比如在 `@media` 中）有一些限制：Sass 不可以将 `@media` 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 `@media` （或者其他 CSS 指令）中使用 `@extend`，必须延伸给相同指令层中的选择器。

## 8. 控制指令 (Control Directives)

SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 [Compass](http://compass-style.org/) 等样式库中。

### 8.1. if()

The built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).

### 8.2. @if

当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码：

```scss
p {
  @if 1 + 1 == 2 { border: 1px solid; }
  @if 5 < 3 { border: 2px dotted; }
  @if null  { border: 3px double; }
}
@if语句只是对应的判断,同时只是满足对应的表达式的时候才会有对应的编译结果出现的.
```

编译为

```css
p {
  border: 1px solid; }
```

`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明，例如：

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
//因为在SASS中使用对应的圆括号可以改变运算的优先级的,所以也完全可以使用对应的原括号的方式来完成对应的优先级的改变.当然在if语句之中是暂时不需要的/
```

编译为

```css
p {
  color: green; }
```

### 8.3. @for

`@for` 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：`@for $var from <start> through <end>`，或者 `@for $var from <start> to <end>`，区别在于 `through` 与 `to` 的含义：*当使用 `through` 时，条件范围包含 `<start>` 与 `<end>` 的值，而使用 `to` 时条件范围只包含 `<start>` 的值不包含 `<end>` 的值*。另外，`$var` 可以是任何变量，比如 `$i`；`<start>` 和 `<end>` 必须是整数值。

```scss
@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}
#{}//将对应的弄为直接的编译方式,
```

编译为

```css
.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }
.item-3 {
  width: 6em; }
```

### 8.4. @each

**`@each` 指令的格式是 `$var in <list>`, `$var` 可以是任何变量名，比如 `$length` 或者 `$name`，而 `<list>` 是一连串的值，也就是值列表。**

`@each` 将变量 `$var` 作用于值列表中的每一个项目，然后输出结果，例如：

```scss
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```

编译为

```css
.puma-icon {
  background-image: url('/images/puma.png'); }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png'); }
.egret-icon {
  background-image: url('/images/egret.png'); }
.salamander-icon {
  background-image: url('/images/salamander.png'); }
```

#### 8.4.1 Multiple Assignment

The @each directive can also use multiple variables, as in @each $var1, $var2, ... in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:

```scss
@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}
//总的来说只要是不放心的地方你就可以加上对应的圆括号实现即可!
```

is compiled to:

```css
.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }
```

Since maps are treated as lists of pairs, multiple assignment works with them as well. For example:

```scss
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
```

is compiled to:

```css
h1 {
  font-size: 2em; }
h2 {
  font-size: 1.5em; }
h3 {
  font-size: 1.2em; }

@each $height, $width in (h1: 2em, h2 : 3em, h3 : 4em) {
    #{height} {
        font-size : $width;
    }
}
```

### 8.5. @while

`@while` 指令重复输出格式直到表达式返回结果为 `false`。这样可以实现比 `@for` 更复杂的循环，只是很少会用到。例如：

```scss
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
.item-6 {
  width: 12em; }

.item-4 {
  width: 8em; }

.item-2 {
  width: 4em; }
```



## 9. 混合指令 (Mixin Directives)

混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 `.float-left`。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。

### 9.1. 定义混合指令 `@mixin` (Defining a Mixin: `@mixin`)

混合指令的用法是在 `@mixin` 后添加名称与样式，比如名为 `large-text` 的混合通过下面的代码定义：

```scss
@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}
```

混合也需要包含选择器和属性，甚至可以用 `&` 引用父选择器：

```scss
@mixin clearfix {
  display: inline-block;
  &:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html & { height: 1px }
}
```

### 9.2. 引用混合样式 `@include` (Including a Mixin: `@include`)

使用 `@include` 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：

```scss
.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
```

编译为

```css
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px; }
```

也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。

```scss
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;
```

编译为

```css
a {
  color: blue;
  background-color: red; }
```

混合样式中也可以包含其他混合样式，比如

```scss
@mixin compound {
  @include highlighted-background;
  @include header-text;
}
@mixin highlighted-background { background-color: #fc0; }
@mixin header-text { font-size: 20px; }
```

混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。

### 9.3. 参数 (Arguments)

参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：

```scss
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue, 1in); }
```

编译为

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }
```

混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：

```scss
@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue); }
h1 { @include sexy-border(blue, 2in); }
```

编译为

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed; }
```

#### 9.3.2. 参数变量 (Variable Arguments)

有时，不能确定混合指令需要使用多少个参数，比如一个关于 `box-shadow` 的混合指令不能确定有多少个 'shadow' 会被用到。这时，可以使用参数变量 `…` 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：

```scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}
.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

编译为

```css
.shadowed {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}
```

参数变量也可以用在引用混合指令的时候 (`@include`)，与平时用法一样，将一串值列表中的值逐条作为参数引用：

```scss
@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$values: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);
}
```

编译为

```css
.primary {
  color: #ff0000;
  background-color: #00ff00;
  border-color: #0000ff;
}
```

## 11. 输出格式 (Output Style)

Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。

Sass 提供了四种输出格式，可以通过 `:style option` 选项设定，或者在命令行中使用 `--style` 选项。

### 11.1. `:nested`

Nested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。

```css
#main {
  color: #fff;
  background-color: #000; }
  #main p {
    width: 10em; }

.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline; }
```

### 11.2. `:expanded`

Expanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。

```css
#main {
  color: #fff;
  background-color: #000;
}
#main p {
  width: 10em;
}

.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline;
}
```

### 11.3. `:compact`

Compact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。

```css
#main { color: #fff; background-color: #000; }
#main p { width: 10em; }

.huge { font-size: 10em; font-weight: bold; text-decoration: underline; }
```

### 11.4. `:compressed`

Compressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。

```css
#main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline}
```



**SASS知识汇总**:  SASS表示语法很棒的样式表。它是一个CSS预处理程序, 用于减少与CSS的重复并节省时间。它为基本语言增添了力量和优雅, 并帮助你添加变量, 嵌套规则, mixin, 内联导入, 继承等, 所有这些都具有与CSS完全兼容的语法。可以更加轻松高效的编写代码,而且很容易维护,是CSS的超集完全可以直接使用CSS的全部功能的,而且有着更加强大的功能和实现.它促进了可重用性方法, 逻辑语句以及一些内置功能, 例如颜色处理, 数学和参数列表项。它是更稳定, 功能更强大的CSS扩展和样式文档, 结构更清晰。它是CSS的超集, 包含CSS的所有功能, 并且是用Ruby编码的开源预处理器。它是一种预处理语言, 提供了CSS语法。



#### HTML文档结构[#](https://www.cnblogs.com/zx125/p/11517218.html#html文档结构)

```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>标题标签</title>
</head>
<body>
 
<h1>我的第一个标题</h1>
 
<p>我的第一个段落。</p>
 
</body>
</html>
```

文档声明头，表示使用哪个HTML版本编译，声明为 HTML5 文档

元素是 HTML 页面的根元素,lang表示用了什么语言，en.表示用了英文，HTML是最外层的标签，他表示网页内容的开始

元素包含了文档的元（meta）数据，如 定义网页编码格式为 **utf-8**。（网页的基本信息）

| **标签** |                           **意义**                           |
| :------: | :----------------------------------------------------------: |
|  title   |                        定义网页的标题                        |
|  style   |                         定义内部样式                         |
|  script  |                   定义JS和引用外部的JS文件                   |
|   link   |                   引用外部的表文件或者样式                   |
|   meta   | 定义网页原信息,针对搜索引擎和更新频度的描述和关键词,用户不可见 |

**meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。**

#### **http-equiv属性**[#](https://www.cnblogs.com/zx125/p/11517218.html#http-equiv属性)

它用来向浏览器传达一些有用的信息，帮助浏览器正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。

#### **name**[#](https://www.cnblogs.com/zx125/p/11517218.html#name)

主要用于页面的关键字和描述，是写给搜索引擎看的，关键字可以有多个用 ‘,’号隔开，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。

```
<meta name="Keywords" content="网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信" />
```

这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到。

```
<meta name="Description" content="网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。" />
```

设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做**SEO**（search engine optimization，搜索引擎优化)。浏览器会根据你的页面描述去body找`h`标题标签，如果有就会把页面描述收录。

** 元素包含了可见的页面内容



**前端CSS选择器内容:**

CSS的三种引入方式：

**内嵌式**

```
<p style='color:red;'>文字颜色为红色</p>
```

**嵌入式**

```
<style type='text/css'>
    p
    {
        color:red;
    }
</style>
```

**外部式**

```
<link rel="stylesheet" href="index.css" type="text/css">
```

**优先级**

内嵌式>嵌入式>外部式

但是`嵌入式>外部式`有一个前提：嵌入式css样式的位置一定在外部式的后面。

#### CSS选择器[#](https://www.cnblogs.com/zx125/p/11517767.html#css选择器)

**基础选择器**

标签选择器

```
p{
	color:red;
}
```

类选择器

```
.class{
	color:red;
}
```

id选择器

```
#id{
	color:red;
}
```

**高级选择器**

后代选择器

div里面的所有p,不止是第一代，是所有子类，也就是包含选择器，后面的全部包含的内容的。

```
div p{
    css代码样式;
}
div .a{
    css代码样式;
}
#b .a{
    css代码样式;
}
```

子代选择器

只对子代有效

```
div>p{
    css代码样式;
}
```

毗邻选择器

div和p互为邻居

```
div+p{
	css代码样式;
}
对p有效
```

兄弟选择器

同一层级的兄弟标签

```
span~.a{
	css代码样式;
}
```

组合选择器

```
h1,span,p{
    color:red;
    font-size:14px;
}
```

属性选择器

div标签有name属性的

```
div[name]{
	css代码样式;
}

属性值为123的
div[name="123"]{
	css代码样式;
}
```

**伪类选择器**

它遵循”爱恨准则“，所谓爱恨就是”LoVe HAte“

```
/* 未访问的链接 */
a:link {
  color: #FF0000
}

/* 已访问的链接 */
a:visited {
  color: #00FF00
} 

/* 鼠标移动到链接上 */
a:hover {
  color: #FF00FF
} 

/* 选定的链接 */ 
a:active {
  color: #0000FF
}

/*input输入框获取焦点时样式*/
input:focus {
  outline: none;
  background-color: #eee;
}
```

**伪元素选择器**

常用的给首字母设置特殊的样式：

```
p:first-letter {
  font-size: 48px;
  color: red;
}
```

**before**

```
/*在每个<p>元素之前插入内容*/
p:before {
  content:"*";
  color:red;
}
```

**after**

```
/*在每个<p>元素之后插入内容*/
p:after {
  content:"[?]";
  color:blue;
}
```

before和after多用于清除浮动。

**优先级：**

​	浏览器通过**优先级**来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类[选择器](https://developer.mozilla.org/en-US/CSS/CSS_Reference#selectors)组成的匹配规则。

![image-20210309104447392](C:\Users\guiyuan\AppData\Roaming\Typora\typora-user-images\image-20210309104447392.png)

计算的时候不会产生进位的，只是单纯的直接相加，没有进位值出现的。当然important！的方式加上的时候则对应的权重最大。

选择器相关内容:https://www.runoob.com/cssref/css-selectors.html **伪元素是那四个!!!!**

属性选择器:新增了3个属性选择器,可以让属性选择器拥有了通配符的概念,

![这里写图片描述](https://img-blog.csdn.net/20180816104833536?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU2ODM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	也就是再CSS2的基础上提出了一些新的方式,对应的是可以拥有通配符实现的/

**2.CSS3 结构性伪类选择器—root**
`:root`选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是`<html>`。
`:root`选择器等同于`<html>`元素，简单点说：

```css
:root{background:orange}
html {background:orange;}
//也就是说:root的就是选择当前的根元素的.
//得到的效果等同。建议使用`:root`方法。
```

**3.CSS3 结构性伪类选择器—not**
`:not`选择器称为否定选择器，和jQuery中的`:not`选择器一模一样，可以选择除某个元素之外的所有元素。
就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成：

```css
input:not([type="submit"]){
  border:1px solid red;
}
```

**4.CSS3 结构性伪类选择器—empty**
`:empty`选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。
比如说，你的文档中有三个段落p元素，你想把没有任何内容的P元素隐藏起来。我们就可以使用`:empty`选择器来控制。

```css
p:empty {
  display: none;
    //也就是让对应的标签中的元素中如何不包含任何内容的时候,直接拥有某些性质!display:none;也就是说不存在的直接不出现即可!
}
```

**5.CSS3 结构性伪类选择器—target**
`:target`选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。

**6.CSS3 结构性伪类选择器—first-child**
`:first-child`选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。

**7.CSS3 结构性伪类选择器—last-child**
`:last-child`选择器与`:first-child`选择器作用类似，不同的是`:last-child`选择器选择的是元素的最后一个子元素。

**8.CSS3 结构性伪类选择器—nth-child(n)**
`:nth-child(n)`选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。

经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。如下表所示：
![这里写图片描述](https://img-blog.csdn.net/20180816110623605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU2ODM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**9.CSS3 only-child选择器**
`:only-child`选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。

**10.CSS3选择器 :enabled和:disabled选择器**
在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器`:enabled`对这些表单元素设置样式。

`:disabled`选择器刚好与`:enabled`选择器相反，用来选择不可用表单元素。要正常使用`:disabled`选择器，需要在表单元素的HTML中设置“disabled”属性。

**11.CSS3选择器 :checked选择器**
在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器`:checked`配合其他标签实现自定义样式。而`:checked`表示的是选中状态。

**12.CSS3选择器 ::selection选择器**
`::selection`伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的。

**13.CSS3选择器 :read-only和read-write选择器**
`:read-only`伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”

`:read-write`选择器刚好与`:read-only`选择器相反，主要用来指定当元素处于非只读状态时的样式。

**14.CSS3选择器 ::before和::after**
`::before`和`::after`这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。记住+是指代后面的元素,当前元素的后面的元素选择.

![img](https://www.w3cplus.com/sites/default/files/css3-selector-lest.png)

前端SEO:

HTML5：

1.<header>：页眉  **（5）hgroup：头部信息/标题的补充内容；** **（8）figure：独立的单元，例如某个有图片与内容的新闻块。**

描述了文档的头部区域，于定义内容的介绍展示区域。

（1）只有必要时使用header，大多数情况下，如果只有h1~h6或**hgroup**，没有其它需要与之组合在一起的伴生内容，就没有必要用header将它包起来。

（2）header与h1~h6元素中的标题是不能互换的，它们都有各自的语义目的。

（3）不能在header里嵌套footer元素或另一个header，也不能在footer或address元素里嵌套header。

（4）header不一定必须包含nav元素，不过在大多数情况下，如果header包含导航性链接，就可以用nav。

2.<nav>：标记导航

标签定义导航链接的部分。无论哪种情况，应该仅对文档中重要的链接群使用nav。通常用一个ul元素（无序列表）对链接列表进行标记，除非链接是**面包屑链接**则使用ol元素（有序列表）。

（1）HTML5不允许将nav嵌套在address元素中。

（2）HTML5规范不推荐对辅助性的页脚链接（使用条款，隐私政策等），所以选择用nav。


3.<article>：文章标记标签

表示文档、页面、应用或网站中一个独立的容器，原则上是可独立分配或可再用的，即聚合。

（1）article可以嵌套在另一个article里面，只要里面的article与外面的article是部分与整体的关系，但是不能将article嵌套在address元素里。

（2）一个article里包含一个或者多个section元素并是不强制性的。

4.<section>：区块定义标签

表示的是文档或是应用的一个一般的区块，一般是有一组相似的主题的内容。

（1）section不是一个像div一样的通用容器，因为section表达一定的含义，而div则没有任何语义上的含义。

**【特别提醒】如何在article和section中作出选择？**

**你的内容是适合做聚合的一块独立的内容或一个小组件吗？如果是，使用article。否则使用section。这并不是意味着你必须聚合或芬达article内容，只是其内容适合这样做。**

5.<aside>：定义侧栏标签

表示一部分内容与页面的主题并不是有很大的关系，可以独立存在。aside的例子包括抬升式引用、侧栏、新闻站上列出相关文章的连接框、广告、nav元素组（如博客的友情链接）、商业站上相关产品列表。

（1）如果子啊侧栏中使用一个或多个aside（或将其作为侧栏使用），应在HTML中将他们放在页面主要内容的后面。将重要的内容放在前面有利于SEO和提升可访问性。

（2）对于与内容有关的图像（如图表、图形或带有说明文字的插图），使用figure而非aside。

（3）HTML5不允许将aside嵌套在address元素中。

6.<footer>：页脚标签

与header标签对应的标签，可以放附录、索引、版权页、许可协议等。

（1）footer元素代表嵌套它的最近的article、aside、nluckquote、body、details、fieldset、figure、nav、section或td元素的页脚。只有当它最近的祖先是body时，它才是整个页面的页脚。

（2）不允许在footer里嵌套header或另一个footer。同时，也不能将footer嵌套在header或address元素里。

前端盒子模型：IE和W3C：

​		可以看出，IE6 盒子模型中，盒子的尺寸包含了 内容区，padding， border 和 margin 这四个部分，而 W3C 的盒子模型中，盒子的尺寸只包含内容区，padding，border 和 margin 被排除在盒子尺寸之外。

![img](https://img-blog.csdn.net/20150629102231720)

也就是说是否包含到外面的border和padding 的内容的方式。如果不包含的时候则是对应的W3C模型，反之。

**也就是说其中的content的内容值包含哪几个部分的方式，IE中定义的宽高是直接包含于外部的border的值的。**需要区分其中的盒子实际占据的大小和对应的内容占据的大小的值。也就是一个宽高包含于border，另外的一个不包含其中的值区别。

cookie和session区别：https://www.cnblogs.com/l199616j/p/11195667.html

  **会话（Session）**跟踪是Web程序中常用的技术，用来**跟踪用户的整个会话**。常用的会话跟踪技术是Cookie与Session。**Cookie通过在客户端记录信息确定用户身份**，**Session通过在服务器端记录信息确定用户身份**。

## **1.1 Cookie机制**

　　在程序中，会话跟踪是很重要的事情。理论上，**一个用户的所有请求操作都应该属于同一个会话**，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。

　　而Web应用程序是使用HTTP协议传输数据的。**HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话**。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。**Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。**https://www.cnblogs.com/l199616j/p/11195667.html

\1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。
\2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
\3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。
所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

https://www.zhihu.com/question/19786827 的

https://www.cnblogs.com/xulb597/archive/2012/07/02/2573252.html

当浏览器禁用cookie的时候https://blog.csdn.net/qq_44973159/article/details/103235481 URL重写、隐藏表单字段。



**BFC (Block formatting context) “块级格式化上下文”：****https://blog.csdn.net/AmberWu/article/details/79543896?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 

Formatting context （格式化上下文） 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。BFC，即Block Formatting Contexts（块级格式化上下文），它属于上述定位方案的普通流。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。通俗一点来讲，可以把BFC，理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。**

**BFC 布局规则：**
内部的Box会在垂直方向，一个接一个地放置。
Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
BFC的区域不会与float box重叠。
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
计算BFC的高度时，浮动元素也参与计算

先来看看常见的定位方式
**定位方案是控制元素的布局，常见的有三种：**

普通流（normal flow）
其实就是元素按照再HTML中的先后位置之上而下布局，在这个过程中，行内元素水平排列，直到当行被沾满然后换行，块级元素则会被渲染为完整的一个新行，除非另外制定，否则所有元素默认都是普通流定位，也可以说，普通六中元素的位置由该元素再HTML文档中的位置决定。
浮动（float）
在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能地向左边或右边偏移，其效果与印刷排版中的文本环绕相似。
绝对定位（absolute positioning）
在绝对定位布局中，元素会整体脱离普通六，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。



### 触发： 

满足下列条件之一就可触发BFC

　　【1】根元素，即HTML元素 
　　【2】float的值不为none 
　　【3】overflow的值不为visible 
　　【4】display的值为inline-block、table-cell、table-caption 
　　【5】position的值为absolute或fixed

### 特性：

**1、阻止垂直外边距（margin-top、margin-bottom）折叠**:重叠的时候是按照以大的为主的，不可以将两者的取值全部显示出来，所以需要创建不同的BFC。

属于同一个BFC的两个相邻块级子元素（元素都要在文档流中）的上下margin会发生重叠—— 分为两个BFC就可以消除这种margin 重叠。

**`解决：`**触发其中一个div的BFC，使得两个div不在同一个 BFC内，这样就可以阻止这两个div的margin重叠.

**2: 可以包含浮动的元素—清除浮动**

说明：我们知道当浮动的盒子的父元素没有高度时，会出现高度塌陷现象。

绿盒子设置浮动前，父盒子被撑开高度：

绿盒子设置浮动后，父盒子高度塌陷：

父盒子触发BFC可以解决这个问题。

 <style>
        .box {
            width: 200px;
            border: 1px solid #ccc;
            overflow：hidden；
        }
        .son {
            width: 100px;
            height: 100px;
            background-color: green;
            float: left;
        }
    </style>

**1：可以阻止元素被浮动的元素覆盖（可做两栏布局自适应）**

绿色盒子浮动遮挡了红色盒子：这时候其实第二个元素有部分被浮动元素所覆盖，(**但是文本信息不会被浮动元素所覆盖**因为使用对应的浮动之后可以理解为当前的文字的层次还是跟浮动的相同的，所以浮动元素不会占据对应的空间，然后可以文字便可可以环绕在当前的浮动元素的周围。是直接在同一个标签中同时使用两者) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190428161126130.png)

触发红色盒子的BFC，可防止被绿色盒子遮挡:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190428161306268.png)

  <style>
        *{
            padding:0;
            margin :0;
        }
        .box {
            width: 400px;
            height: 100px;
            margin: 0  auto;
        }
        .green {
            width: 100px;
            height: 50px;
            float: left;
            background-color: green;
        }
        .red {
            width: 200px;
            height: 100px;
            /* float: left; */
            /* display: inline-block; */
            /* display: table-cell; */
            /* overflow: hidden; */
            /* position: absolute; */
            /* position: fixed; */
            background-color: red;
        }
    </style>


**浮动和定位：https://www.cnblogs.com/zx125/p/11523776.html ** 实现文字环绕1..

​	元素怎样浮动：元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。**一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。**而且总之，浮动元素的位置停下来的情况是遇到父级的边框为止，当是相同等级的浮动元素的时候则会自动的排列在同一行中，假如当前的空间足够的情况下。虽然浮动元素浮动过去了但是实际上还是：

**内容默认提升半层，为1.5层，文档流的层为1，但是文字的层级为1.5，所以会出现文字环绕的现象**

如果是设置了float的时候，如果外部的框没有设置为触发BFC的情况下，会出现内部的高度完全没有的情况。设置了overflow:hidden来完成触发BFC的时候，则不会再出现高度坍塌。

如果把几个元素放在一起的话，只要有空间存在的时候，则对应是彼此相邻的状态。元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。

**4、父项塌陷解决方案（建议使用）:清除浮动**

```
        .parent:after{
            content:"";
            display: block; //这个是必须的！
            clear:both;
        }
```

**定位：**

https://www.cnblogs.com/angle6-liu/p/10131980.html 理解定位的实现和区别

浮动相关；https://www.cnblogs.com/yjiangling/p/12620203.html

## position[#](https://www.cnblogs.com/zx125/p/11523776.html#position)

css **position**属性用于指定一个元素在文档中的定位方式。`top`，`right`，`bottom`，`left`属性则决定了该元素的最终位置。

| 属性值   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| static   | **默认。静态定位**， 指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 `top`, `right`, `bottom`, `left` 和 `z-index`属性无效。 |
| relative | **相对定位**。 元素先放置在未添加定位时的位置，在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白），**相对于自身位置进行坐标移动，原先的位置也是继续保留的，而且会占据先得位置，不会脱离正常得文档流。** |
| absolute | **绝对定位**。不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。相对于父元素进行移动得，不占据位置，原先位置不会被保留，同时还会造成父元素的高度坍塌。绝对定位的元素完全从文档流当中移走，所以他们的尺寸无法影响到父元素的尺寸。<br/>如果你真的想实现绝对定位还能撑开父元素，只能通过JavaScript实现：获取到绝对定位的子元素的高度，再设置给父元素。<br/>或者，用 float: left / float:right 还有 margin 来调整位置，子元素再通过父元素设置的overflow:hidden来撑开父元素。 |
| fixed    | **固定定位**。 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变 |

#### relative[#](https://www.cnblogs.com/zx125/p/11523776.html#relative)

**1.不脱离文档流**

**参考点**

以原来的位置作为参考点，可以进行top,left,right,bottom进行位移。元素按照原本的元素自身的位置进行偏移参考，然后使用对应的四个值来进行定位的实现。

**注意**

由于相对的位置是原来的位置，坐标轴为第4象限，y轴是相反的

#### absolute[#](https://www.cnblogs.com/zx125/p/11523776.html#absolute)

1.脱离文档流

2.层级提高

**参考点**

父标签的位置

#### static：[#](https://www.cnblogs.com/zx125/p/11523776.html#static：)

无特殊定位，对象遵循正常文档流。top，right，bottom，left等属性不会被应用。

相对于最近的非static祖先元素定位，如果没有非static祖先元素，那么以页面左上角进行定位`子绝父相`

#### fixed[#](https://www.cnblogs.com/zx125/p/11523776.html#fixed)

1.脱离文档流

**参考点**

html左上角为参考点

#### z-index[#](https://www.cnblogs.com/zx125/p/11523776.html#z-index)

1. z-index只应用在定位的元素，默认z-index:auto;
2. z-index取值为整数，数值越大，它的层级越高
3. 如果元素设置了定位，没有设置z-index，那么谁写在最后面的，表示谁的层级越高。
4. 从父现象。通常布局方案我们采用`子绝父相`，比较的是父元素的z-index值，哪个父元素的z-index值越大，表示子元素的层级越高。

# [CSS块级-内联元素，盒子模型](https://www.cnblogs.com/zx125/p/11518760.html)

## CSS元素[#](https://www.cnblogs.com/zx125/p/11518760.html#css元素)

#### 元素分类和区别[#](https://www.cnblogs.com/zx125/p/11518760.html#元素分类和区别)

**常用的块状元素有：**

```
<div>、<p>、<h1>~<h6>、<ol>、<ul>、<li>、<dl>、<dt>、<table>、<form>
```

**常用的内联元素有**

```
<a>、<span>、<i>、<em>、<strong>、<label>
```

**常见的内联块状元素有**

```
<input>、<img> 在同一行内显示，而且是可以设置对应的宽高的。
```

**区别**

| 标签类别   | 特点                                                  |
| ---------- | ----------------------------------------------------- |
| 块状元素   | 1.独自占据整一行 2.可以设置宽高（默认是父标签的100%） |
| 行内元素   | 1.所有的内联元素在一行内显示 2.不可以设置宽高         |
| 行内块元素 | 1.在一行内显示 2.可以设置宽高                         |

#### 常见属性[#](https://www.cnblogs.com/zx125/p/11518760.html#常见属性)

**display**

用于控制HTML元素的显示效果。

| 值                     | 意义                                                         |
| :--------------------- | :----------------------------------------------------------- |
| display:"none"         | HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。 |
| display:"block"        | 默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。 |
| display:"inline"       | 按行内元素显示，此时再设置元素的width、height、margin-top、margin-bottom和float属性都不会有什么影响。 |
| display:"inline-block" | 使元素同时具有行内元素和块级元素的特点。（可以在一行内显示 ，可以设置宽高） |

**display:"none"与visibility:hidden的区别：**

visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。

display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。

**display与line-height** ： **margin外边框的距离是水平叠加垂直方向重叠合并。**

一般用于a标签和span标签

**文字垂直居中：**

```
display:inline-block;
height:40px;
line-height:40px;
```

line-height是行高 height是高度 字体的行框高度是根据字体的font-size决定

**font-style**

字体样式

| 属性值  | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| normal  | 默认的，文本设置为普通字体                                   |
| italic  | 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。常用 |
| oblique | 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。 |



**em和rem的使用：**

**SEO：**https://blog.csdn.net/yuyuking/article/details/89374794

<meta name="Description" Content="你网页的简述">

<meta name="Keywords" Content="关键词1,关键词2,关键词3,关键词4″>

![img](https://img-blog.csdnimg.cn/20190418112017675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1eXVraW5n,size_16,color_FFFFFF,t_70)

**CSS水平垂直居中:**

**请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？**

**FLEX布局:**http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html



**jQuery知识总结：**下标也是从0 开始往后计算的。

1选择器：基础选择器，层次选择器，过滤选择器（基本过滤和内容过滤）选择器，属性过滤选择器，子元素过滤器，表单对象属性过滤选择器，表单选择器：

2使用的是  \ \ 的方式来进行特殊字符的转义的。

<div id='id#b'></div>其中包含有特殊的字符#的操作所以必须使用转义的方式来求出对应的选择器：$("#id\ \#b")的方式来完成的，记住其中的\ \ 是有两条\的存在的。

3.JQ对象和DOM对象的转变的时候使用的方式为[indedx]或者是get(index)的方式实现的。

var $cr = $("#cr");

var cr = $cr[0]; 或者是使用的方法为：var cr = $cr.get(0);

然后DOM对象转换为jQ的对象的时候只需要将对应的加上$();的符号对于原本生成的变量进行取值即可！

而且记住Jquery中选择器返回的内容全部都是对象，即使对应的元素是不存在的，所以在判断其是否存在的时候不可以直接单纯的判断，需要判断其的length的值是否大于0的方式来判别其是否为空的。

4.一般而言DOM的操作分为3个方面的：DOM core(核心)和HTML-DOM和CSS-DOM：

创建一些新的元素节点的方式：var $li_1 = $("<li></li>"); 即可同时传递于双引号中的内容可以是</li>也可以是对应的完成的标签前后同时定义，但是不可以是开头标签或者是大写的标签值。当然其中的标签中完全可以包含着任何的文本内容！同时是无论其中的标签的代码多么复杂都是可以使用其完成创建的。

创建好对应的标签的之后就可以直接使用对应的append()的方式来进行插入其中的。

append()的方式是完成加入到当前选择器的子类之中去的。

删除节点：remove() \ detach() \ empty() 最后一个是清空当前节点之中的内容的方法。然而前面的两者都哦是删除整个节点的。

包裹节点和替换节点：一般替换的时候对应的节点的事件是没有啦！

5JQ中很多的属性操作的时候都是将get和set函数集成于一个函数中的，当传递的只有一个参数的时候则是获取，当传递的参数的个数为2个的时候则是设置修改，当需要同时修改多个的时候需要将对应的使用对象的方式包含起来然后进行设置/

`var $para = $("p");`

`var p_txt = $para.attr("title");*// huoqu*`

`$("p").attr("title", "you title"); *//shezhi*` 哪怕其中的属性是class的也可以

`$("p").attr({`

  `"title": "you title",`

  `"name": "you name"`

`});`

css()的方法得到的高度值跟样式的设置有关，有可能是具体的数值也有可能是auto等，即样式中是什么就是什么，然后height()得到的就是具体的实际高度的值。所以使用的时候也应该区分！height()和width()的值是一样的，只要是对应的有参数就是设置值，没有参数的时候就是获取值。



window.onload() 和 $(document).ready(fuunction(){ 

})  \\\    $(function(){

}) 在jq中对应的事件的名字比原生的js中少了一个on的字符串的。所以在原生的j中都是有一个对应的on的

  

##### **JavaScript面试题目：**

**1 介绍JavaScript的基本数据类型**
Number、String 、Boolean 、Null、Undefined
Object 是 JavaScript 中所有对象的父对象
数据封装类对象：Object、Array、Boolean、Number 和 String
其他对象：Function、Arguments、Math、Date、RegExp、Error
新类型：Symbol

**2 说说写JavaScript的基本规范？**
1) 不要在同一行声明多个变量
2) 使用 ===或!==来比较true/false或者数值
3) switch必须带有default分支
4) 函数应该有返回值
5) for if else 必须使用大括号
6) 语句结束加分号
7) 命名要有意义，使用驼峰命名法

**3 jQuery使用建议**
1) 尽量减少对dom元素的访问和操作
2) 尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件
处理函数合并到一个处理函数，通过数据状态来处理分支
3) 尽量避免使用toggle事件

**4 Ajax使用**
全称 ： Asynchronous Javascript And XML
所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。
创建Ajax的过程：
1) 创建XMLHttpRequest对象（异步调用对象）

```text
var xhr = new XMLHttpRequest();
```

2) 创建新的Http请求（方法、URL、是否异步）

```text
xhr.open(‘get’,’example.php’,false);
```

3) 设置响应HTTP请求状态变化的函数。
onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。
4) 发送http请求

```text
xhr.send(data);
```

5) 获取异步调用返回的数据
注意：
1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。
2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。
3) 尽量减少ajax请求次数
4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。

**5 JavaScript有几种类型的值？你能画一下他们的内存图吗？**
基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。
两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能
引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

**6 栈和堆的区别？**
栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；
堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。

**7 Javascript实现继承的几种方式**：**Javascript创建对象的几种方式？**

可以参考我的另一篇文章[JavaScript实现类与继承的方法（全面整理）](https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000013253890)

**9 Javascript作用链域**：
作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。只有函数有块级作用域存在，然后在后续的let和const出来之后才对应有了新的作用域链的概念。

**10 谈谈this的理解**
1) this总是指向函数的直接调用者（而非间接调用者）
2) 如果有new关键字，this指向new出来的那个对象
3) 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。

**11 eval是做什么的？**
它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。

**12 什么是window对象? 什么是document对象?**
window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。

**13 null，undefined的区别？**
null表示一个对象被定义了，但存放了空指针，转换为数值时为0。
undefined表示声明的变量未初始化，转换为数值时为NAN。
typeof(null) -- object;
typeof(undefined) -- undefined

**33 回流与重绘**

**44 渐进增强与优雅降级**

**45 Web Worker和Web Socket？**

**46 JS垃圾回收机制？**

47什么是FOUC（无样式内容闪烁）？如何避免出现？



**CSS中calc,support,media各自的含义及用法？**

```css
@support //条件判断其是否支持对应的属性，支持的时候有一套样式，不支持的时候再有一套样式。
```
CSS中的@support主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，**你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。**但是这里有一点需要注意的是：@support对于浏览器的版本也是有要求的，不是说所有的浏览器以及其所有的版本都是支持@support的。

.逻辑操作符：“not” 的用法

```css
@supports not (display: flex) {  
    div {    
        float: right;  
    }
}

@supports (display: flex) and ( box-shadow: 2px 2px 2px black ) {
	/*自己的样式*/
}

注释：如果浏览器支持display:flex 和 box-shadow的属性，就执行里面自己的样式

or and 意思跟具体的相似的，同时使用的时候完全和上面的方法相同的。

@supports (display: -webkit-flex) or (display: -moz-flex) or(display: flex) {
      /*自己的样式 */
}

//也可以完全使用圆括号来改变运算的优先级的，来组合使用对应的属性！
@supports ((transition-property: color) or (animation-name: foo)) and (transform: rotate(10deg)) { 
	/*自己的样式 */
}
@supports (transition-property: color) or ((animation-name: foo) and (transform: rotate(10deg))) {
        /*自己的样式 */
}

@supports (display: grid) and (not (transition-property: color) or (animation-name: foo)){
/*自己的样式 */
    div{
        
    }
}
/因为本身检测是否浏览器支持的，然后才在其中进行对应的代码书写，完成对应的样式。


## calc

calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-”, “*”, “/” 运算；

#accessory {
    border: 8px solid #B8C172;
    float: right;
    padding: 10px;
    width: 208px; /* Fallback for browsers that don't support the calc() function */
    width: -moz-calc(25% - 10px );
    width: -webkit-calc(25% - 10px );
    width: calc(25% - 10px );
}

media   媒体查询的实现！
@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。
当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。
@media screen and (max-width: 300px) {
    body {
        background-color:lightblue;
    }
}

```

![image-20210310102008821](C:\Users\guiyuan\AppData\Roaming\Typora\typora-user-images\image-20210310102008821.png)



#### IndexDB:http://www.ruanyifeng.com/blog/2018/07/indexeddb.html

#### JS 中数组API：https://blog.csdn.net/weixin_39644462/article/details/103459370

#### CORS：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS

#### 函数防抖和函数节流：https://www.jianshu.com/p/b7b698db8352

前者保证每次执行时候,只要是再次触发就会重新开始计算时间的,后者使用一个标记,代表当前函数是否执行结束,假如没有执行结束的时候,直接返回退出函数的,不会让其继续执行.



## 1rem、1em、1vh、1px各自代表的含义？

> rem

rem是全部的长度都相对于根元素<html>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。

> em

- 子元素字体大小的em是相对于父元素字体大小
- 元素的width/height/padding/margin用em的话是相对于该元素的font-size

> vw/vh

全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。

> px

px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

一般电脑的分辨率有{1920*1024}等不同的分辨率

1920*1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素

## 画一条0.5px的直线？

> 考查的是css3的transform

```css
height: 1px;
transform: scale(0.5);
```

## 画一个三角形？

> 这属于简单的css考查，平时在用组件库的同时，也别忘了原生的css

```css
 .a{
            width: 0;
            height: 0;
            border-width: 100px;
            border-style: solid;
            border-color: transparent #0099CC transparent transparent;
            transform: rotate(90deg); /*顺时针旋转90°*/
 }

<div class="a"></div>
transparent:透明的意思！
```

## 清除浮动的几种方式，及原理？

> 清除浮动简单，但这题要引出的是BFC，BFC也是必考的基础知识点

- `::after / <br> / clear: both` 或者是创建新的标签来使用其中的clear：both的方式。
- 创建父级 `BFC`(overflow:hidden)
- 父级设置高度

> *BFC （*块级格式化上下文*）*，是一个独立的渲染区域，让处于 `BFC` 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

*触发条件:*

- 根元素
- `position: absolute/fixed`
- `display: inline-block / table`
- `float` 元素
- `ovevflow !== visible`

*规则:*

- 属于同一个 `BFC` 的两个相邻 `Box` 垂直排列
- 属于同一个 `BFC` 的两个相邻 `Box` 的 `margin` 会发生重叠
- `BFC` 的区域不会与 `float` 的元素区域重叠
- 计算 `BFC` 的高度时，浮动子元素也参与计算
- 文字层不会被浮动层覆盖，环绕于周围

#### 页面渲染html的过程？

> 不需要死记硬背，理解整个过程即可

浏览器渲染页面的一般过程：

1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。

2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

3.DOM Tree + CSSOM --> 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。

DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。

![img](https://img-blog.csdnimg.cn/20190719201031648.png)

1.解析HTML以构建DOM树 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个标签都是DOM树中的1个节点。

2.解析css样式：浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体 ，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。

3.构建渲染树：DOM Tree 和样式结构体组合后构建render tree，render tree不同于DOM树，render tree能识别样式，render tree中每个NODE都有自己的style，而且 render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。

4.布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。 +

5.绘制渲染树：遍历渲染树，每个节点将使用UI后端层来绘制

#### web前端在什么情况下会触发重排和重绘

重绘：dom节点的css样式颜色的变化过程叫做重绘 **改变的是cssTree 一部分变化**，对randerTree影响相对较小。所以相对与重排而言对浏览器性能影响较小
**`回流(reflow)`**重排：**js动态的修改dom 即更改了DOM树了 更改dom树之后 renderTree就变了**，renderTree变了也就是要重新建立一个renderTree了 ，这个过程叫做重排。

回流触发的情况：页面首次渲染；浏览器窗口大小发生改变；元素尺寸或位置发生改变；元素内容变化（文字数量或图片大小等等）；元素字体大小变化；添加或者删除可见的DOM元素；触发display
重绘触发条件：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它。
性能优化：**避免频繁的样式操作，最好一次性重写style,或者一次性更改class,避免频繁操作dom,对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。**因为动画中会涉及到位置和样式的更新，所以对应的就需要完成

回流什么时候发生？

```
1、添加或者删除可见的DOM元素；

2、元素位置改变；

3、元素尺寸改变——边距、填充、边框、宽度和高度

4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；

5、页面渲染初始化；

6、浏览器窗口尺寸改变——resize事件发生时；
```

重绘的产生：
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如
visibility、outline、背景色等属性的改变。

```
`var s = document.body.style;`
`s.padding = "2px"; // 回流+重绘`
`s.border = "1px solid red"; // 再一次 回流+重绘`
`s.color = "blue"; // 再一次重绘`
`s.backgroundColor = "#ccc"; // 再一次 重绘`
`s.fontSize = "14px"; // 再一次 回流+重绘`
`// 添加node，再一次 回流+重绘`
`document.body.appendChild(document.createTextNode('abc!'));`
```



4. 如何性能优化？

  ```
  减少回流与重绘的次数，就需要简单对渲染树的操作。
  
  直接使用className修改样式，少用style设置样式
  
  让要操作的元素进行”离线处理”，处理完后一起更新（使用display:none技术，减少回流和重绘的次数）
  
  将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。
  ```

  

     4. 尽量不要在 for 循环中, 进行样式获取性操作
    
     5. 使用 translate 代替 left/top 等, translate 只触发了 重绘, 不会触发回流, 节约一次回流的时间
    
     6. 通过 opacity 替换 visibility, 改透明度渲染效率更高
    
     7.不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局
    
     8.将多次改变样式属性的操作合并成一次操作。
#### CORS、http、https、跨域：

#### 说一下继承的几种方式及优缺点？

#### 如何中断ajax请求？

一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort()

#### [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

也就是将事件委托在父级元素之上，然后利用事件冒泡的机制来完成对应的事件。

一些新增的节点之后，也需要新增的节点上具有对应的事件存在，然而一般的简单实现是没有的，但是可以将原先的遍历方式定义为一个函数，在新增节点完成之后，对应调用一次函数即可。但是其实际上性能很差！看下面的代码：
            

```javascript
window.onload = function(){
    	var oBtn = document.getElementById("btn");
   	 	var oUl = document.getElementById("ul1");
    	var aLi = oUl.getElementsByTagName('li');
    	var num = 4;
        //鼠标移入变红，移出变白
        for(var i=0; i<aLi.length;i++){
            aLi[i].onmouseover = function(){
                this.style.background = 'red';
            };
            aLi[i].onmouseout = function(){
                this.style.background = '#fff';
            }
        }
        //添加新节点
        oBtn.onclick = function(){
            num++;
            var oLi = document.createElement('li');
            oLi.innerHTML = 111*num;
            oUl.appendChild(oLi);
        };
    }
```
这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下：
            

```javascript
window.onload = function(){
        var oBtn = document.getElementById("btn");
        var oUl = document.getElementById("ul1");
        var aLi = oUl.getElementsByTagName('li');
        var num = 4;
        function mHover () {
            //鼠标移入变红，移出变白
            for(var i=0; i<aLi.length;i++){
                aLi[i].onmouseover = function(){
                    this.style.background = 'red';
                };
                aLi[i].onmouseout = function(){
                    this.style.background = '#fff';
                }
            }
        }
        mHover ();
        //添加新节点
        oBtn.onclick = function(){
            num++;
            var oLi = document.createElement('li');
            oLi.innerHTML = 111*num;
            oUl.appendChild(oLi);
            mHover ();
        };
    }
            
```
```javascript
window.onload = function(){
        var oBtn = document.getElementById("btn");
        var oUl = document.getElementById("ul1");
        var aLi = oUl.getElementsByTagName('li');
        var num = 4;
        //事件委托，添加的子元素也有事件
        oUl.onmouseover = function(ev){
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if(target.nodeName.toLowerCase() == 'li'){
                target.style.background = "red";
            }
            
        };
        oUl.onmouseout = function(ev){
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if(target.nodeName.toLowerCase() == 'li'){
                target.style.background = "#fff";
            }
            
        };
        
        //添加新节点
        oBtn.onclick = function(){
            num++;
            var oLi = document.createElement('li');
            oLi.innerHTML = 111*num;
            oUl.appendChild(oLi);
        };
    }
```
直接使用事件委托的方式，直接便可以完成对应的新增的节点也有用对应的事件的效果，不但性能优化，而且代码简单。

#### javascript的宏任务和微任务https://blog.csdn.net/lc237423551/article/details/79902106 看玩promise之后接着看。

#### 数组操作的API：https://blog.csdn.net/weixin_39644462/article/details/103459370

#### get、post的区别：

> 此题比较简单，但一定要回答的全面

1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&进行参数分割。psot将参数存放在HTTP的包体内

2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制

3.get后退不会有影响，post后退会重新进行提交

4.get请求可以被缓存，post不可以被缓存

5.get请求只URL编码，post支持多种编码方式

6.get请求的记录会留在历史记录中，post请求不会留在历史记录

7.get只支持ASCII字符，post没有字符类型限制

#### 跨域问题：

同源：协议、域名、端口

###### **一、 通过jsonp跨域**

通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

1.）原生实现：

```javascript
 <script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

服务端返回如下（返回时即执行全局函数）：

```json
handleCallback({"status": true, "user": "admin"})
```

2.）jquery ajax：

```jquery
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```

**jsonp缺点：只能实现get一种请求。**

#### **二、 document.domain + iframe跨域**

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

1.）父窗口：(http://www.domain.com/a.html)

```java
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

2.）子窗口：(http://child.domain.com/b.html)

```javascript
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

#### WebSocket:一种服务器主动向客服端提供数据的方式

​	**WebSocket**是一种在单个[TCP](https://baike.baidu.com/item/TCP)连接上进行[全双工](https://baike.baidu.com/item/全双工)通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。**在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输**。

​	很多网站为了实现推送技术，所用的技术都是轮询，比如一些实时比赛得分的更新！短轮询是不断的建立连接去请求对应的数据，然而长轮询是持续的保持对应的连接。两者都让资源非常的浪费。然后comet中技术实现长短轮询的方式：很多网站为了实现[推送技术](https://baike.baidu.com/item/推送技术)，所用的技术都是[轮询](https://baike.baidu.com/item/轮询)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出[HTTP请求](https://baike.baidu.com/item/HTTP请求/10882159)，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的[头部](https://baike.baidu.com/item/头部)，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。然后在轮询中对应的存在两种方式：长轮询和短轮询两种。区别在于是否立即发送数据回到对应的客户端。

**其他特点包括：**

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

#### **ES6模块的设计：**https://www.cnblogs.com/unclekeith/p/7679503.html

CommonJS模块输出的是一个值的复制，ES6输出的是一个值的引用。NODE就是使用得CommonJS得。

module.exports = {

}

require()

export and import 

CommonJS模块是运行时加载的，ES6模块是编译时输出接口的。

第一个中：值的复制代表着，输出之后的值是永远不会再改变的，可以对其进行修改，但是不会在收到之前的模块内的代码影响了。

然而再ES6中的时候，对应的类似于引入的是一个符号链接的形式，所以其不可以再当前引入的模块中进行修改操作。而且其的值是会跟着原先的模块中的值得改变而继续改变得。

而且对应得顶层的this指针是指向undefined的，但是CommonJS模块的顶层this指向当前的模块的。这也是一个很大的区别！

## CommonJS模块与ES6模块的区别

到目前为止，已经实习了3个月的时间了。最近在面试，在面试题里面有题目涉及到模块循环加载的知识。趁着这个机会，将CommonJS模块与ES6模块之间一些重要的的区别做个总结。语法上有什么区别就不具体说了，主要谈谈引用的区别。

转载请注明出处：[CommonJS模块与es6模块的区别](http://www.cnblogs.com/unclekeith/p/7679503.html)

### CommonJS

1. 对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。
2. 对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。
3. 当使用require命令加载某个模块时，就会运行整个模块的代码。
4. 当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
5. 循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

### ES6模块

1. ES6模块中的值属于【动态只读引用】。
2. 对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
3. 对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。
4. 循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。

上面说了一些重要区别。现在举一些例子来说明每一点吧



变量、作用域、内存问题：

基本类型的值：可以直接操作保存在变量中的实际的值，复制之后不同的值是完全独立的，另外一个的操作不会影响其余的一个的值。存储在栈内存之中的，函数传递值的时候方法完全相同的。

js不允许直接访问内存中的位置，也就是说不可以直接操作对象的内存空间的，在操作对象的时候，实际上只是操作对象的引用而不是实际的对象值。为此，引用类型的值都是按照引用访问的。只能给引用的数据类型添加对一个的属性值得。实际的值存储在堆内存之中的，但是其的引用是存储在栈之中的，所以实际的修改的时候会修改到堆内存中的值，会导致两个值都发生改变的。也是复制其中在栈区的数据，但是此时的数据可以理解为是一个指针，两者指向的是同一个在堆区的数据，所以修改其中的一个的时候都会修改另外一个。函数传值的时候也是传递的引用，哪怕在内部重新声明一个对象并对于改对象进行一定的修改。其都是修改的原本的那个对象的引用的。

检测基本数据类型的时候typeof的是很有效果的，但是在检测对应的引用数据类型的时候其没有什么太大的作用的。使用instanceof的方法其可以检测当前的引用对象是属于什么样的引用类型，variable instanceof constructor前者对应位定义的引用变量，后者对应是对象类型。当右边是Object的时候始终返回的是true的值的。

使用var声明的变量是具有变量提升的性质的， 会被提升到当前作用域的顶端去的。是被添加到最近的环境中的，函数中则是添加到当前函数之中去的，不会直接添加到全局的环境之中去的。如果没有使用var关键字的时候则会提升到全局作用域中去，非常的不提倡的方式，需要在代码书写的时候注意的。

JS中的垃圾回收机制：

函数中的变量都是局部变量的，一般在使用结束之后就被释放，当然是需要使用关键字var的方式来进行声明的。

标记清楚和引用计数：后者当出现循环引用的时候是会出现很大的问题的，不建议使用的。可以使用在不使用对应的对象的时候将对象指向位null的值。垃圾收集的周期时间设置，根据当前时间段中每次 到达对应的一个指标后在进行收集，平时编写代码的时候养成一个好的习惯就是当前不用的对象的时候则将其的值指向位null的。

第五章：引用类型：

 

```javascript
Object类型：
//所有的对象都具有三那个方法因为是来资源Object().prototype()上的方法
toLocalString();
toString();
valueOf();

var a = {
	name : "zhang",
	age: 19
}
//对象字面量的

var a = new Object(); //构造函数的方式。

而且在引用类型中其中的属性都是按照字符串的方式进行定义的/不论是什么方式定义的都是字符串的形式的。
访问的时候可以使用.的方式，也可以使用中括号的方式访问：
person["name"]; //而且其中可以传递一个变量的
var na = "name";
person[na]; //成立的
person.name;
```

```javascript
Array：
//数据类型可以不相同，可以是任何的数据类型的数据。大小是可以动态调整的，随着添加自动变大的。

var colors = new Array("black");
var colors = [];
var len = colors.length; //而且可以直接修改length的值，完成截断数组的效果
//新增的和截断的数组元素都是undefined的值
var colors = ["black"];
colors[length] = "white"; //使用这样的方式可以完成数组元素添加的

//判断一个是否为数组的方式！
value instanceof Array;
Array.isArray(value);

Object.prototype.toString().call(value);//因为在任何值上调用Object原生的toString的方法，都会得到返回的是一个[object, NaticeConsteuctorName]格式的字符串，每个类都一个[[Class]]属性指向就是对应的字符串中的构造函数名。

var res = colors.join(",");//

//栈方法：删除就返回为值，插入就返回为数组的新长度。

//数组尾部操作
push() //前者为返回的都是修改之后的数组的长度值
pop()   //返回的是最后一个被添加进去的元素

//数组头部操作
shift()//返回的被删除的项
unshift()  //返回的也是新数组的长度值


arr.reverse();
arr.sort();
arr.sort(cmp);
var nums = [1, 9, 2, 3, 8, 5, 10];
function cmp(a, b) {
    return a > b;
}
nums.sort(cmp);

concat();//没有参数只是返回副本,有数组作为参数则将全部数组的全部元素组合起来返回副本,如果只有一个值的时候则加入当前的数组之中去的.返回的是副本不影响原本传递的参数

slice();//截取数组,一个参数的时候则是起始位置到最后的位置,两个参数就是区间内的元素.
slice(-2, -1) == silce(-2 + length, -1 + length) //当其中的前面的值大于后面的值的时候返回为空的.


splice();//删除,两个参数的.可以理解第一个元素就是想要删除的位置,然后第二个元素就是想要删除的个数,最后几个就是需要添加进去的元素的值,可以为空,也就是说至少有两个参数的.可以完成删除,插入,替换(删除后在插入的实现)

nums.indexOf(2); //查找 从前面往后
nums.lastInedxOf(2); // 从后往前.

迭代方法:
every();
filter();
forEach();
map();
some();


var nums [1,2,3,4,5,6,7,8];
var everyResult = nums.every(function(item, index, array) {
    return (item > 2);
});
//每一个都满足
var someResult = nums.every(function(item, index, array) {
    return (item > 2);
});
//只需要一个满足 返回的都是true或者false的值.


var filterResult = nums.every(function(item, index, array) {
    return (item > 2);
}); //得到的是满足性质的数组元素

var mapsResult = nums.every(function(item, index, array) {
    return item * 2;
}); //返回的是执行操作之后的数组的元素

nums.forEach(function(item, index, array) {
    return (item > 2);
}); //遍历数组的

reduce()
reduceRight()
//传递的是四个值,前一个值,当前值,数组的下标,数组对象的
var sum = nums.reduce(function(prev, cur, index, array){
    return prev + next ;
});
```



```javascript
//Function类型: 函数也是对象的,函数名是指针的.记住函数名本身也是指针的，

function sum(num1, num2)
{
	return num1 + num2;
    //函数声明方式,会有变量提升的情况存在的, 在其之前使用不会出现错误的/
}

let sum = function(num1, num2) {
	return num1 + num2;
}

//也就是说函数名字其实和其它的完全相同的,都是对象的,其的名字只是指针,所以必须记住.名字复制后还是可以使用的.
//没有重载,后面实现的函数的方式会直接覆盖之前实现的方法.

//函数的除了可以作为值返回之外还可以作为对应的函数参数进行使用的。
//函数内部的属性：
     arguments 和 this 
//arguments中有callee的属性，该属性是一个指针的，其指向拥有这个arguments的对象的函数
function facorial(num) {
    if(num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);  //严格模式下会出现错误！
    }
}

//this引用的是函数执行的环境对象--或者说this的值只要当前网页在什么作用域下执行this对象就指向谁。重点是执行的作用域而不是定义其的作用域的环境，在于执行的。
//因为在调用函数之前，this的值是不确定的， 因此this的会在代码执行过程中引用不同的对象的。
caller:
//得到当前调用本函数的函数的代码：其会返回当前调用者的代码：
function outer()
{
    inner();
}
function inner()
{
    alert(inner.caller);
    //alert(arguments.callee.caller); 严格模式下不可以使用的。
    //arguments.callee == inner;
}
outer();
//函数包含的属性和方法：
length \  prototype 


apply() call()  //两者都是非继承而来的。等同于设置函数体内的this对象的值。前者接受两个参数，一个是运行函数的
//作用域，另外一个是参数数组。

//强大的地方在于可以扩充函数运行的作用域。

function sum(num1, num2) 
{
    return num1 + num2 ;
}
function callSum1(num1, num2) {
    return sum.apply(this, arguments);
}
function callSum2(num1, num2) {
    return sum.apply(this, [num1, num2]);
}
alert(callSum1(10, 10)); // 20
alert(callSum2(10, 10)); // 20

call();//方法相同的，只是必须将对应的传递的参数全部例举出来，不可以使用数组！

apply() call() bind() 
//三者都是申明的函数来进行调用的，然后传递的参数可能不同，得到的结果也不一样，bind()是得到的对应的为一个函数的实例，前两者只是单纯的修改对应函数的this指针的作用域的。

//不是全部的参数都需要传递的，只是传递第一个参数的时候则可以修改其中函数的作用域的
window.color = "res";
var o = {color : " black"};
function saycolor() {
    alert(this.color);
}
saycolor() ;  //res

saycolor(this); //res
saycolor(window); //res
saycolor(o); //blue;

bind();//这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值的。

window.color = "red";
var o = {color: "blue"};
function saycolor() {
    alert(this.color);
}
var objectSayColor = saycolor.bind(o);。只是特定的绑定了其的作用域的 

P118


```

```javascript
基本包装类型：String Number，Boolean P119中的。
//基本
var s1 = "text";
s1.color = "black";
alert(s1.color); undefined
//因为只有引用的数据类型才是永远存在的，其余的是存在代码执行
Boolean类型：
	//布尔表达式中的所有的对象都是会被转换为true的，所以使用的时候应该格外小心。
var falseObject = new Boolean(flase);
var res = falseObject && true;
alert(res); // true  // 因为全部的对象在bool表达式中都是转换为true的。

//不论是是三者中的哪种，只要使用new进行申明的时候返回的typeof的值都是Object的值。

String:
slice()//一个参数就是开始的位置，两个参数就是开始位置到结束位置。负数的时候则是加上整个字符串的长度后求解
substr()//一个参数为开始位置，两个参数的时候第二个指定的为返回的字符串的个数。负数的时候将第一个加上长度，第二个变为0
substring() // 一个两个的时候跟slice()规则相同，但是负数的时候将全部的都转换为0


Math：
	Math.ceil(); //向上舍入
	Math.floor();//向下舍入
	Math.round();//数学中正常的舍入。

不准给undefined、NaN、Infinity赋值，不论是什么模式都会出现错误的！
```

```javascript
//面向对象的程序设计：
var person = new Object();
person.name = "zhagng";

//对象字面量的方式
var person = {
    name : "zhang",
    age: 19,
    sayName: function(){
        alert(this.name);
    }
}

//数据属性
[[Configurable]]: true  delete删除属性值
[[Enumerable]]:true  for in 编译
[[Writable]]:true 修改属性值
[[Value]]: undefined 属性的具体取值

//修改上面的三者必须用：Object.defineProperty(); //属性所在对象，属性名字，一个描述符对象（也就是上面的四）

//如果修改之后，再次按照原本的操作去操作的话在非严格模式下面会出现直接忽略操作，在严格模式下面则会出现报错的！
//而且配置一次之后再次配置的时候会出现错误的。只是可以配置一次的。严格模式下的
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "NSF"
});
alert(person.name);
delete person.name // 在严格模式下会出现报错的

//访问器属性
[[Configurable]]: true  delete删除属性值
[[Enumerable]]:true  for in 编译
[[Get]]
[[Set]]
Object.defineProperties(book, {
    _year: {
        writable: true,
        value: 2004
    },
    year:{
      get:function(){
          
      }  
    },
});
//只需要传递两个参数的， 所以只是传递的为两个参数即可。第一个是对应的对象的，后者为对应的属性修改的值。
既然上面的两个方式是设置或者是修改！相同的有获取的方式函数：
Object.getOwnPropertyDesciptor(); //两个参数一个是对象一个是对应的属性值

6.2创建对象：//

//实例的constructor的值就是对应的构造函数，实例的constructor也是根据原型链上得到的，因为在原型链是共享的。

//工厂模式:缺点还是没有解决对应的对象识别的问题

//构造函数方式：可以解决上诉问题，但是每一个方法在每一个实例上都被重新创建一次的。对象中创建的函数是每一个实例都有一个不同的函数的，在类的外部声明后再赋值的时候则不一样的， 因为此时的值就是一个指针而已！

//原型模式：每个函数都有一个prototype的属性值，这个属性是一个指针，指向的是一个对象的，所有的实例都会共享其中的方法的。


```

```javascript
//BOM: 浏览器对象模型
//全局变量不可以通过delete的删除,而且直接在window对象上定义的属性可以.

var pageWidth = window.innerWidth;
var pageHeight = window.innerHeight;

if(typeof pageWidth != "number" ){
    
}
window.open(); //四个参数:URL\ 窗口的目标\ 一个特性字符串\ 一个表示新打开的是否取代浏览器历史记录中当前加载页面的bool值.

//第二个参数取值有:
//_self:当前窗口\ _blank:新的窗口打开  
//_parent:属性作用使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。
//target="_top" ， 属性作用使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。

//第三个参数表现是一些很多的字符串,可以显示很多的性质的字符串的.


```

```javascript
//客户端检测

```

```javascript
//10:DOM:
//文档节点只有一个子节点,即<html>元素,称为文档元素.

Array.prototype.alice(arguments);//可以将类数组转换为数组的形式
someNode.nodeType
someNode.childNodes
someNdoe.parentNode
someNode.previousSibling
someNode.nextSibling
someNode.firstChild == someNode.childNodes[0]
someNde.lastChild == someNode.childNodes[someNode.childNodes.length - 1]
someNode.hasChildNodes();//判断是否存在子节点,存在则为true的
//这些都是只读的


var returnNode = someNdoe.appendChild(newNode);
var returnNode = someNode.insertBefore(newNode, null); //第二个参数控制插入到谁的前面
var returnNode = someNode.replaceChild(newNode, someNode.firstNode);//第二个参数指出需要被替换的节点的位置
var returnNode = someNode.removeChild(someNode.lastChild);

cloneNode(); //一个bool的参数用于表示是否执行深复制还是浅复制


document:

var html = document.documentElement; == document.childNodes[0] == document.firstChild;
//得到的都是html的
var body = document.body;
var doctype = document.doctype;

document.title
document.URL;
document.domain;
document.referrer;

var div = document.getElementById("#id");
var div = document.getElementsByTagName("div"); //只要是有s的得到都是一个类数组的结果!
var radios = document.getElementsByName(""); //属性name的值进行查找的!

var hasXmlDom = document.implementtation.hasFeature("XML", "1.0");
//这个是用来完成DOM以执行检测的!

在js代码中使用</script>标签的时候需要注意使用对于其中的/进行转义操作
"<\/script>";

如果在整个文档加载结束之后才使用document.write()的方法的时候会导致全部内容全部重写的

window.onload = funnction(){
    document.write("123");
}

Element类型:

var div = document.getElementById("div");
alert(div.tagName);
alert(div.nodeName == tagName);


var div = document.getElementById("div");
div.id;
div.className;
div.title;
div.lang;
div.dir;

取得属性:

//getAttribute();
//setAttribute();
//removeAttribute();
自定义的属性一般需要加上data-属性来完成对应的以便于区分的.

var div = document.createElement("div");
document.body.appendChild(div);

appendData(text);
deleteData(offset, text);
insertDate(offset, text);


var script = documnt.createElement("script");
script.type = "text/javascript";
script.src = "client.js";
document.body.appendChild(script);


var link = document.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
var head = document.getElementsByTagName("head")[0];
head.appendChild(link);

//d
```

```javascript
//DOM 拓展:
querySelector();
var body = document.querySelector("#id / .class"); //传递的是一个css的选择器,得到的是第一个元素
var body = document.querySelectorAll(""); //参数是一样的.

someNode.childElementCount; 
someNode.firstElementChild;
someNdoe.lastElemetnChild;
someNode.previousElementSibling;
someNode.nextElementSibling;
//加上Element的值完全查找到结果都是元素的,不会是文本节点,也不会是注释的结果!


var classname = document.getElementsByClassName();
```

```javascript
DOM2事件处理函数:   每个圈里的细节学习加强!

addEventListener();
removeEventListener();
//三个参数第一个是事件,第二个是回调,想要使用后者删除不可以申明为匿名函数,第三个为bool值表示是否在事件捕获期间处理程序.true代表在事件捕获期间,false代表在事件冒泡期间处理.

var btn = document.getElementById("#id");
btn.addEventListener("click", function(){
    alert(this.id);
}, true);
//匿名函数无法删除的!

IE中的事件:

attachEvent();  // this  == window   DOM中是等于对应的执行环境的
detachEvent();

//而且addEventListener()的作用域是当前执行的环境,attachEvent()的作用域始终都是对应的window的环境之中的,然后在添加相同的事件多个函数的时候,前者是按照顺序执行的,但是后者是按照顺序的方向执行的,而且后者默认始都是冒泡阶段的!

事件对象:

DOM中的:event  P355中的单词的使用含义:

```

```javascript
JSON:
//是javascript的严格子集,利用js中的一些模式来表示结构化数据
性质:
简单值:但是不支持对应的undefined
对象:
数组:
json字符串必须加上双引号,单引号会导致语法错误
json中必须将对应的属性也加上双引号
而且最后的一项中没有末尾分号

JSON.stringify():将js对象序列化为JSON字符串 stringify() -> JSON()
JSON.parse():将JSON字符串解析为原生JS

JSON.stringify(book);
JSON.stringify(book, ["title", "edition"]);
JSON.stringify(book, function(key, value) {
    switch(key) {
        case "authors":
		return value.join(",")
    }
});

```

```javascript
//AJAX:COMET:
var xhr = new XMLHttpRequest();
xhr.open();
xhr.send(null);

xhr.responseText; //响应的主题被返回的文本
xhr.reponseXML;
xhr.status; //相应的HTTP状态码
xhr.statusText; //状态的说明

xhe.readyState; 0 1 2 3 4  //这个是会随时更新的,其的每一次更新都会导致触发下面的onreadystatechange函数的执行, 在处理的时候可以监听其的改变来完成事件处理/

xhr.onreadystatechange = function() {
	if(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
        alert(xhr.responseText);
    }    
}

xhr.abort();  //在得到响应之前终止对应的请求!


function submitData() {
    var xhr = createXHR();
    xhr.onreadystatechange = function() {
        if(xhr.readState == 4) {
            if(xhr.status >= 200 && xhr.status < 300 || xhr.status ==304) {
                alert(xhr.responseText);
            } else {
                alert("request" + xhr.status);
            }
        }
    };
    xhr.open("post", "postexample.php", true);
    xhr.setRequestHeader("Content_Type", "application/x-www-form-urlencoded");
    var form = document.getElementById("user-info");
    xhr.send(serialize(form));
    
}

xhr.setRequestHeader("Content_Type", "application/x-www-form-urlencoded"); 
//可以对其中的报文信息的头部进行设置修改的!

xhr.timeout = 1000;
xhr.ontimeoout = function() {
    alert("da");
}
xhr.send(null);



跨域资源共享:  https://juejin.cn/post/6844903882083024910
	协议\端口\域名  image标签和script标签是没有同域限定的!
   <script>
        var script = document.createElement('script');
        script.type = 'text/javascript';

        // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
        script.src = 				 'http://www.domain2.com:8080/loginuser=admin&callback=handleCallback';
        document.head.appendChild(script);

        // 回调执行函数
        function handleCallback(res) {
            alert(JSON.stringify(res));
        }
 	</script>
  
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",  // 自定义回调函数名
    data: {}
});



```

```javascript
Cookie:https://zhuanlan.zhihu.com/p/146050407   一般不会超过4k的数据大小的
	前端持久化之浏览器存储技术:

前端持久化之浏览器存储技术（localStorage、sessionStorage 、session、cookies、indexDB）:
	
	//Web Storage实际上由两部分组成：sessionStorage与localStorage。 Web Storage带来的好处： 1.减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，减少不必要的数据请求，且减少数据在浏览器和服务器间不必要地来回传递。 2.快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。 3. 存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。 4. 存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本地，不会与服务器发生任何交互。 5. 更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，使得数据操作更为简便（如：getItem\setItem）。 6. 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。
localStorage
//单个localStorage的大小受限，可以用多个iframe方式使用多个域名来突破单个页面下localStorage存储数据的最大限制。 特别说明，浏览器多个标签页打开同个域名时，localStorage内容一般是共享的。其位置这可以监听事件“storage”来做一致性操作响应处理。这样会导致如下现象： 标签页一：通过某行为修改localStorage中某个属性值，然后数据接口依赖该属性值； 标签页二：由于localStorage标签页间共享，导致标签页二数据不准确！
localStorage.setItem("type","1")  // 使浏览器在其localStorage内存中存储一个叫type的属性 ，其值为1；
localStorage.getItem("type")       // 获取localStorage中相应属性
	

sessionStorage
//和localStorage功能类似，但是sessionStorage在浏览器关闭时会自动清空。 sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的。 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。
    
Cookie
//Cookie为了辨别用户身份（参见，客户端识别与cookie机制）或Session跟踪而存储在用户浏览器端的数据。Cookie一般会通过HTTP请求发送给服务器端。 cookie过期等配置 Cookie分为：Session Cookie和持久型Cookie。Cookie设置中有个HttpOnly参数，前端浏览器使用document.cookie是读取不到HttpOnly类型的Cookie的，被设置为HttpOnly的Cookie记录只能通过HTTP请求头发送到服务器端进行读写操作，这样就避免了服务器的Cookie记录被前端javascript修改，保证了服务器验证Cookie的安全性。

//cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。

//这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

session
//session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。

WebSQL：
//二维表的形成存储大量数据到客户端，但目前只有Chrome浏览器有。 IndexDB：在客户端存储大量结构化数据并且在这些数据上使用索引进行高性能检索的一套API，类似于NoSQL。 **Application Cache：**通过manifest配置文件在本地有选择性地存储javascript、css、图片等静态资源文件的文件缓存机制，已废弃。 cacheStorage：在ServiceWorker规范中定义的，用于保存每个ServiceWorker（后续博文会单独介绍）声明的Cache对象，未来可能替代Application Cache的离线方案。 Flash缓存：主要基于Flash，具有读写浏览器本地目录的功能。


sessionStorage 、localStorage 和 cookie 比较
共同点：都是保存在浏览器端，且同源的。 区别：

/是否随请求传递 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。/
/存储大小限制不同 cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
/数据有效期不同 sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； 但是只保存在当前这个浏览器中，换了浏览器，数据就会是另一个浏览器打开时保存的数据，因为这些数据都是存储在浏览器中的； cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。/
/作用域不同 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的； cookie也是在所有同源窗口中都是共享的。


//cookie 和session比较///
区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要在每个请求中携带，可以放在COOKIE中 其他本地化的缓存数据存储在Web Storage
```

```
面试题:
1.页面导入样式时，使用link和@import有什么区别？
    本质上，这两种方式都是为了加载CSS文件，但还是存在着细微的差别

    1 老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。

    link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。

    2 加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显.

    3 兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。

    4 使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。


```

